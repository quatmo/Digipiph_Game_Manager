/* * Digipiph Game Manage v 1.0 *  * NO COPYRIGHTS OR LICENSES. DO WHAT YOU LIKE. *  * http://digipiph.com *  * File generated: Thur Dec 30 14:04 EST 2013 *///establish Digipiph Game Manager namespacethis.dgm = this.dgm || {};(function(window) {  //general  dgm.canvas = dgm.canvas || {};                     //stores game canvases  dgm.sprites = dgm.sprites || {};                   //stores game sprites  dgm.images = dgm.images || {};                     //stores game images  dgm.collisionObjects = dgm.collisionObjects || {}; //stores game collisionObjects  dgm.collisionObjects.size = 0;                     //stores counter of game collisionObjects  dgm.keypressObjects = dgm.keypressObjects || {};   //stores game keypressObjects  dgm.keypressObjects.size = 0;                      //stores counter of game keypressObjects  /****************************  * dgm.setupCanvas(canvas)  * Defines a canvas and configures the stage, width, and height  * canvas = canvas object  ****************************/  dgm.setupCanvas = function(canvas) {    dgm.canvas[canvas.id] = {};    dgm.canvas[canvas.id]['id'] = canvas.id;    dgm.canvas[canvas.id]['stage'] = new createjs.Stage(canvas);    dgm.canvas[canvas.id]['width'] = canvas.width;    dgm.canvas[canvas.id]['height'] = canvas.height;    //return the canvas object    return dgm.canvas[canvas.id];  };  /****************************  * dgm.configSprite(sprite, canvas)  * Defines a sprite and its canvas  * sprite = sprite object  * canvas = canvas object  ****************************/  dgm.configSprite = function(sprite, canvas) {    //make sure sprite exist    if (!sprite.id) {      alert('Sprite not properly configured!');      return false;    }    //make sure canvas exist    if (!canvas.id) {      alert('Canvas not properly configured!');      return false;    }    //check if sprite exist    if (dgm.sprites[sprite.id]) {      alert('Sprite "'+sprite.id+'" already defined.');      return false;    }    //define the sprite    dgm.sprites[sprite.id] = {};    //set the id    dgm.sprites[sprite.id]['id'] = sprite.id;    //parent canvas    dgm.sprites[sprite.id]['canvas'] = canvas.id;    //current direction    dgm.sprites[sprite.id]['currentDirection'] = (sprite.currentDirection) ? sprite.currentDirection : 'down';    //setup movement    if (sprite.movement) {      dgm.sprites[sprite.id]['movement'] = sprite.movement;    }    //constructor:    var localSpriteSheet = new createjs.SpriteSheet({      "framerate": sprite.framerate,      "images": [sprite.images],      "frames": sprite.frames,      "animations": sprite.animations    });    //create the Sprite    dgm.sprites[sprite.id]['sprite'] = new createjs.Sprite(localSpriteSheet);    //position    dgm.sprites[sprite.id]['sprite']['x'] = sprite.x;    dgm.sprites[sprite.id]['sprite']['y'] = sprite.y;    //add sprite's "tick"    dgm.sprites[sprite.id]['sprite'].addEventListener("tick", function() { dgm.handleMovement(dgm.sprites[sprite.id]); });    //collision object    if (sprite.collisionObject) {      //store collision type      dgm.sprites[sprite.id]['collisionType'] = sprite.collisionType;      //onCollision      if (sprite.onCollision) dgm.sprites[sprite.id]['onCollision'] = sprite.onCollision;      //store the alphaThreshold      dgm.sprites[sprite.id]['collisionAlphaThreshold'] = (sprite.collisionAlphaThreshold) ? sprite.collisionAlphaThreshold : 0;      //store the collision object      var colIndex = (dgm.collisionObjects.size) ? dgm.collisionObjects.size : 0;      dgm.collisionObjects[colIndex] = dgm.sprites[sprite.id];      dgm.collisionObjects.size++;    }    //onEventKeypress    dgm.sprites[sprite.id]['eventKeypress'] = new Array();    dgm.sprites[sprite.id]['onEventKeypress'] = function(key, fn) {      //set the key to its function      dgm.sprites[sprite.id]['eventKeypress'][key] = fn;      //add to the list of keypressObjects      var colIndex = (dgm.keypressObjects.size) ? dgm.keypressObjects.size : 0;      dgm.keypressObjects[colIndex] = dgm.sprites[sprite.id];      dgm.keypressObjects.size++;    }    //return the sprite object    return dgm.sprites[sprite.id];  };    /****************************  * dgm.configImg(img, canvas)  * Defines an image and its canvas  * img = image object  * canvas = canvas object  ****************************/  dgm.configImg = function(img, canvas) {    //make sure image exist    if (!img) {      alert('Image not defined!');      return false;    }    //make sure canvas exist    if (!canvas.id) {      alert('Canvas not properly configured!');      return false;    }    //define the image    dgm.images[img.id] = {};    //set the id    dgm.images[img.id]['id'] = img.id;    //parent canvas    dgm.images[img.id]['canvas'] = canvas.id;    //set the image    var imageObj =  new createjs.Bitmap(img.src);    dgm.images[img.id]['image'] = imageObj;    dgm.images[img.id]['image']['x'] = img.x;    dgm.images[img.id]['image']['y'] = img.y;    //collision object    if (img.collisionObject) {      //store collision type      dgm.images[img.id]['collisionType'] = img.collisionType;      //onCollision      if (img.onCollision) dgm.images[img.id]['onCollision'] = img.onCollision;      //store the alphaThreshold      dgm.images[img.id]['collisionAlphaThreshold'] = (img.collisionAlphaThreshold) ? img.collisionAlphaThreshold : 0;      //store the collision object      var colIndex = (dgm.collisionObjects.size) ? dgm.collisionObjects.size : 0;      dgm.collisionObjects[colIndex] = dgm.images[img.id];      dgm.collisionObjects.size++;    }    //onEventKeypress    dgm.images[img.id]['eventKeypress'] = new Array();    dgm.images[img.id]['onEventKeypress'] = function(key, fn) {      //set the key to its function      dgm.images[img.id]['eventKeypress'][key] = fn;      //add to the list of keypressObjects      var colIndex = (dgm.keypressObjects.size) ? dgm.keypressObjects.size : 0;      dgm.keypressObjects[colIndex] = dgm.images[img.id];      dgm.keypressObjects.size++;    }    //return the image object    return dgm.images[img.id];  };  /****************************  * dgm.handleKeyDown(e, sprite)  * Triggers when a key is pressed  * e = window event  * sprite = sprite affected  ****************************/  dgm.handleKeyDown = function(e, sprite) {    if (!e) var e = window.event;    if (e.keyCode) {      code = e.keyCode;    }	else if (e.which) {      code = e.which;    }    if (!code) return false;    var sprite_id = (sprite) ? sprite.id : false;    if (sprite_id) {      //sprite is specified      switch(code) {        case dgm.sprites.sprite_id.movement.keycodeUp:     dgm.sprites.sprite_id.movement.upHeld = true; return false;        case dgm.sprites.sprite_id.movement.keycodeDown:   dgm.sprites.sprite_id.movement.dnHeld = true; return false;        case dgm.sprites.sprite_id.movement.keycodeLeft:   dgm.sprites.sprite_id.movement.lfHeld = true; return false;        case dgm.sprites.sprite_id.movement.keycodeRight:  dgm.sprites.sprite_id.movement.rtHeld = true; return false;      }    }    else {      //sprite is not specified      if (dgm.sprites) {        //loop through sprites        for (var sprite_id in dgm.sprites) {          var spriteObj = dgm.sprites[sprite_id];          if (spriteObj.movement) {            switch(code) {              case spriteObj.movement.keycodeUp:     spriteObj.movement.upHeld = true; return false;              case spriteObj.movement.keycodeDown:   spriteObj.movement.dnHeld = true; return false;              case spriteObj.movement.keycodeLeft:   spriteObj.movement.lfHeld = true; return false;              case spriteObj.movement.keycodeRight:  spriteObj.movement.rtHeld = true; return false;            }          }          //START: check for eventKeypress events          for (var i=0; i < dgm.keypressObjects.size; i++) {            //don't check for keypress with itself            if (spriteObj.id == dgm.keypressObjects[i].id) continue;            //check only for collision if keypressObject uses the pressed key            if (!dgm.keypressObjects[i].eventKeypress[code]) continue;            //check for collision type            if (spriteObj.collisionType == 'pixel' && dgm.keypressObjects[i].collisionType == 'pixel') {              //use the highest alphaThreshold              var alphaThreshold = (spriteObj.collisionAlphaThreshold > dgm.keypressObjects[i].collisionAlphaThreshold) ? spriteObj.collisionAlphaThreshold : dgm.keypressObjects[i].collisionAlphaThreshold;              //check for sprite collision              if (dgm.keypressObjects[i].sprite) {                if (ndgmr.checkPixelCollision(spriteObj.sprite, dgm.keypressObjects[i].sprite, alphaThreshold)) {                  dgm.keypressObjects[i].eventKeypress[code]();                  return false;                }              }              //check for image collision              if (dgm.keypressObjects[i].image) {                if (ndgmr.checkPixelCollision(spriteObj.sprite, dgm.keypressObjects[i].image, alphaThreshold)) {                  dgm.keypressObjects[i].eventKeypress[code]();                  return false;                }              }            }            else {              //check for sprite collision              if (dgm.keypressObjects[i].sprite) {                if (ndgmr.checkRectCollision(spriteObj.sprite, dgm.keypressObjects[i].sprite)) {                  dgm.keypressObjects[i].eventKeypress[code]();                  return false;                }              }              //check for image collision              if (dgm.keypressObjects[i].image) {                if (ndgmr.checkRectCollision(spriteObj.sprite, dgm.keypressObjects[i].image)) {                  dgm.keypressObjects[i].eventKeypress[code]();                  return false;                }              }            }                      }          //END: check for eventKeypress events        } //END: for      } //END: dgm.sprites    } //END: sprite_id  };  /****************************  * dgm.handleKeyUp(e, sprite)  * Triggers when a key is released  * e = window event  * sprite = sprite affected  ****************************/  dgm.handleKeyUp = function(e, sprite) {    if (!e) var e = window.event;    if (e.keyCode) {      code = e.keyCode;    }	else if (e.which) {      code = e.which;    }    if (!code) return false;    var sprite_id = (sprite) ? sprite.id : false;    if (sprite_id) {      //sprite is specified      switch(code) {        case dgm.sprites.sprite_id.movement.keycodeUp:     dgm.sprites.sprite_id.movement.upHeld = false; return false;        case dgm.sprites.sprite_id.movement.keycodeDown:   dgm.sprites.sprite_id.movement.dnHeld = false; return false;        case dgm.sprites.sprite_id.movement.keycodeLeft:   dgm.sprites.sprite_id.movement.lfHeld = false; return false;        case dgm.sprites.sprite_id.movement.keycodeRight:  dgm.sprites.sprite_id.movement.rtHeld = false; return false;      }    }    else {      //sprite is not specified      if (dgm.sprites) {        //loop through sprites        for (var sprite_id in dgm.sprites) {          var sprite = dgm.sprites[sprite_id];          if (sprite.movement) {            switch(code) {              case sprite.movement.keycodeUp:     sprite.movement.upHeld = false; return false;              case sprite.movement.keycodeDown:   sprite.movement.dnHeld = false; return false;              case sprite.movement.keycodeLeft:   sprite.movement.lfHeld = false; return false;              case sprite.movement.keycodeRight:  sprite.movement.rtHeld = false; return false;            }          }        } //END: for      } //END: dgm.sprites    } //END: sprite_id  };  /****************************  * dgm.handleMovement(spriteObj)  * Triggers during "tick" and if sprite has movement  * spriteObj = sprite object affected  ****************************/  dgm.handleMovement = function(spriteObj) {    //make sure sprite is allowed to move    if (!spriteObj.movement) {      return false;    }    /**********    * START: Helper functions    **********/    function playAnimation(dir) {      switch(dir) {        case"left": spriteObj.sprite.gotoAndPlay("left"); break;        case"right": spriteObj.sprite.gotoAndPlay("right"); break;        case"up": spriteObj.sprite.gotoAndPlay("up"); break;        case"down": spriteObj.sprite.gotoAndPlay("down"); break;        case"upLeft": spriteObj.sprite.gotoAndPlay("upLeft"); break;        case"upRight": spriteObj.sprite.gotoAndPlay("upRight"); break;        case"downLeft": spriteObj.sprite.gotoAndPlay("downLeft"); break;        case"downRight": spriteObj.sprite.gotoAndPlay("downRight"); break;        case"stopped":           switch(spriteObj.currentDirection) {            case"left": spriteObj.sprite.gotoAndStop("left"); break;            case"right": spriteObj.sprite.gotoAndStop("right"); break;            case"up": spriteObj.sprite.gotoAndStop("up"); break;            case"down": spriteObj.sprite.gotoAndStop("down"); break;            case"upLeft": spriteObj.sprite.gotoAndStop("upLeft"); break;            case"upRight": spriteObj.sprite.gotoAndStop("upRight"); break;            case"downLeft": spriteObj.sprite.gotoAndStop("downLeft"); break;            case"downRight": spriteObj.sprite.gotoAndStop("downRight"); break;          }        break;      }    }    function chkCollision(dir) {      var spriteObj_width = spriteObj.sprite.spriteSheet._frameWidth;      var spriteObj_height = spriteObj.sprite.spriteSheet._frameHeight;      switch(dir) {        case"left":          //check stage          if (spriteObj.sprite.x - spriteObj.movement.distanceOnPress > 0) {            //advance the spriteObj's position            spriteObj.sprite.x -= spriteObj.movement.distanceOnPress;            //run collision checker            var collides = runCollisionCheck();            //resets the spriteObj's position            spriteObj.sprite.x += spriteObj.movement.distanceOnPress;            if (!collides) return true;          }          break;        case"right":          //check stage          if (spriteObj.sprite.x + spriteObj_width + spriteObj.movement.distanceOnPress < dgm.canvas[spriteObj.canvas].width) {            //advance the spriteObj's position            spriteObj.sprite.x += spriteObj.movement.distanceOnPress;            //run collision checker            var collides = runCollisionCheck();            //resets the spriteObj's position            spriteObj.sprite.x -= spriteObj.movement.distanceOnPress;            if (!collides) return true;          }          break;        case"up":          //check stage          if (spriteObj.sprite.y - spriteObj.movement.distanceOnPress > 0) {            //advance the spriteObj's position            spriteObj.sprite.y -= spriteObj.movement.distanceOnPress;            //run collision checker            var collides = runCollisionCheck();            //resets the spriteObj's position            spriteObj.sprite.y += spriteObj.movement.distanceOnPress;            if (!collides) return true;          }          break;        case"down":          //check stage          if (spriteObj.sprite.y + spriteObj_height + spriteObj.movement.distanceOnPress < dgm.canvas[spriteObj.canvas].height) {            //advance the spriteObj's position            spriteObj.sprite.y += spriteObj.movement.distanceOnPress;            //run collision checker            var collides = runCollisionCheck();            //resets the spriteObj's position            spriteObj.sprite.y -= spriteObj.movement.distanceOnPress;            if (!collides) return true;          }          break;        case"upLeft":          //check stage          if ((spriteObj.sprite.x - spriteObj.movement.distanceOnPress > 0) && (spriteObj.sprite.y - spriteObj.movement.distanceOnPress > 0)) {            //advance the spriteObj's position            spriteObj.sprite.x -= spriteObj.movement.distanceOnPress;            spriteObj.sprite.y -= spriteObj.movement.distanceOnPress;            //run collision checker            var collides = runCollisionCheck();            //resets the spriteObj's position            spriteObj.sprite.x += spriteObj.movement.distanceOnPress;            spriteObj.sprite.y += spriteObj.movement.distanceOnPress;            if (!collides) return true;          }          break;        case"upRight":          //check stage          if ((spriteObj.sprite.x + spriteObj_width + spriteObj.movement.distanceOnPress < dgm.canvas[spriteObj.canvas].width) && (spriteObj.sprite.y - spriteObj.movement.distanceOnPress > 0)) {            //advance the spriteObj's position            spriteObj.sprite.x += spriteObj.movement.distanceOnPress;            spriteObj.sprite.y -= spriteObj.movement.distanceOnPress;            //run collision checker            var collides = runCollisionCheck();            //resets the spriteObj's position            spriteObj.sprite.x -= spriteObj.movement.distanceOnPress;            spriteObj.sprite.y += spriteObj.movement.distanceOnPress;            if (!collides) return true;          }          break;        case"downLeft":          //check stage          if ((spriteObj.sprite.x - spriteObj.movement.distanceOnPress > 0) && (spriteObj.sprite.y + spriteObj_height + spriteObj.movement.distanceOnPress < dgm.canvas[spriteObj.canvas].height)) {            //advance the spriteObj's position            spriteObj.sprite.x -= spriteObj.movement.distanceOnPress;            spriteObj.sprite.y += spriteObj.movement.distanceOnPress;            //run collision checker            var collides = runCollisionCheck();            //resets the spriteObj's position            spriteObj.sprite.x += spriteObj.movement.distanceOnPress;            spriteObj.sprite.y -= spriteObj.movement.distanceOnPress;            if (!collides) return true;          }          break;        case"downRight":          //check stage          if ((spriteObj.sprite.x + spriteObj_width + spriteObj.movement.distanceOnPress < dgm.canvas[spriteObj.canvas].width) && (spriteObj.sprite.y + spriteObj_height + spriteObj.movement.distanceOnPress < dgm.canvas[spriteObj.canvas].height)) {            //advance the spriteObj's position            spriteObj.sprite.x += spriteObj.movement.distanceOnPress;            spriteObj.sprite.y += spriteObj.movement.distanceOnPress;            //run collision checker            var collides = runCollisionCheck();            //resets the spriteObj's position            spriteObj.sprite.x -= spriteObj.movement.distanceOnPress;            spriteObj.sprite.y -= spriteObj.movement.distanceOnPress;            if (!collides) return true;          }          break;      }      return false;    }        function runCollisionCheck() {      //check collision objects      for (var i=0; i < dgm.collisionObjects.size; i++) {        //don't check for collision with itself        if (spriteObj.id == dgm.collisionObjects[i].id) continue;        //check for collision type        if (spriteObj.collisionType == 'pixel' && dgm.collisionObjects[i].collisionType == 'pixel') {          //use the highest alphaThreshold          var alphaThreshold = (spriteObj.collisionAlphaThreshold > dgm.collisionObjects[i].collisionAlphaThreshold) ? spriteObj.collisionAlphaThreshold : dgm.collisionObjects[i].collisionAlphaThreshold;          //check for sprite collision          if (dgm.collisionObjects[i].sprite) {            if (ndgmr.checkPixelCollision(spriteObj.sprite, dgm.collisionObjects[i].sprite, alphaThreshold)) {              if (dgm.collisionObjects[i].onCollision) dgm.collisionObjects[i].onCollision(spriteObj, dgm.collisionObjects[i]);              return true;            }          }          //check for image collision          if (dgm.collisionObjects[i].image) {            if (ndgmr.checkPixelCollision(spriteObj.sprite, dgm.collisionObjects[i].image, alphaThreshold)) {              if (dgm.collisionObjects[i].onCollision) dgm.collisionObjects[i].onCollision(spriteObj, dgm.collisionObjects[i]);              return true;            }          }        }        else {          //check for sprite collision          if (dgm.collisionObjects[i].sprite) {            if (ndgmr.checkRectCollision(spriteObj.sprite, dgm.collisionObjects[i].sprite)) {              if (dgm.collisionObjects[i].onCollision) dgm.collisionObjects[i].onCollision(spriteObj, dgm.collisionObjects[i]);              return true;            }          }          //check for image collision          if (dgm.collisionObjects[i].image) {            if (ndgmr.checkRectCollision(spriteObj.sprite, dgm.collisionObjects[i].image)) {              if (dgm.collisionObjects[i].onCollision) dgm.collisionObjects[i].onCollision(spriteObj, dgm.collisionObjects[i]);              return true;            }          }        }      }      return false;    }    /**********    * END: Helper functions    **********/    //handle moving left    if (spriteObj.movement.lfHeld && (!spriteObj.movement.rtHeld && !spriteObj.movement.upHeld && !spriteObj.movement.dnHeld)) {      if (chkCollision('left')) spriteObj.sprite.x -= spriteObj.movement.distanceOnPress;      if (spriteObj.currentDirection != 'left') {        spriteObj.currentDirection = 'left';        playAnimation('left');      }    }    //handle moving right    if (spriteObj.movement.rtHeld && (!spriteObj.movement.lfHeld && !spriteObj.movement.upHeld && !spriteObj.movement.dnHeld)) {      if (chkCollision('right')) spriteObj.sprite.x += spriteObj.movement.distanceOnPress;      if (spriteObj.currentDirection != 'right') {        spriteObj.currentDirection = 'right';        playAnimation('right');      }    }    //handle moving up    if (spriteObj.movement.upHeld && (!spriteObj.movement.lfHeld && !spriteObj.movement.rtHeld && !spriteObj.movement.dnHeld)) {      if (chkCollision('up')) spriteObj.sprite.y -= spriteObj.movement.distanceOnPress;      if (spriteObj.currentDirection != 'up') {        spriteObj.currentDirection = 'up';        playAnimation('up');      }    }    //handle moving down    if (spriteObj.movement.dnHeld && (!spriteObj.movement.lfHeld && !spriteObj.movement.rtHeld && !spriteObj.movement.upHeld)) {      if (chkCollision('down')) spriteObj.sprite.y += spriteObj.movement.distanceOnPress;      if (spriteObj.currentDirection != 'down') {        spriteObj.currentDirection = 'down';        playAnimation('down');      }    }    //handle moving up + left    if (spriteObj.movement.upHeld && spriteObj.movement.lfHeld && (!spriteObj.movement.rtHeld && !spriteObj.movement.dnHeld)) {      if (chkCollision('upLeft')) {        spriteObj.sprite.x -= spriteObj.movement.distanceOnPress;        spriteObj.sprite.y -= spriteObj.movement.distanceOnPress;      }      if (spriteObj.currentDirection != 'upLeft') {        spriteObj.currentDirection = 'upLeft';        playAnimation('upLeft');      }    }    //handle moving up + right    if (spriteObj.movement.upHeld && spriteObj.movement.rtHeld && (!spriteObj.movement.lfHeld && !spriteObj.movement.dnHeld)) {      if (chkCollision('upRight')) {        spriteObj.sprite.x += spriteObj.movement.distanceOnPress;        spriteObj.sprite.y -= spriteObj.movement.distanceOnPress;      }      if (spriteObj.currentDirection != 'upRight') {        spriteObj.currentDirection = 'upRight';        playAnimation('upRight');      }    }    //handle moving down + left    if (spriteObj.movement.dnHeld && spriteObj.movement.lfHeld && (!spriteObj.movement.rtHeld && !spriteObj.movement.upHeld)) {      if (chkCollision('downLeft')) {        spriteObj.sprite.x -= spriteObj.movement.distanceOnPress;        spriteObj.sprite.y += spriteObj.movement.distanceOnPress;      }      if (spriteObj.currentDirection != 'downLeft') {        spriteObj.currentDirection = 'downLeft';        playAnimation('downLeft');      }    }    //handle moving down + right    if (spriteObj.movement.dnHeld && spriteObj.movement.rtHeld && (!spriteObj.movement.lfHeld && !spriteObj.movement.upHeld)) {      if (chkCollision('downRight')) {        spriteObj.sprite.x += spriteObj.movement.distanceOnPress;        spriteObj.sprite.y += spriteObj.movement.distanceOnPress;      }      if (spriteObj.currentDirection != 'downRight') {        spriteObj.currentDirection = 'downRight';        playAnimation('downRight');      }    }    //handle player has stopped    if (!spriteObj.movement.lfHeld && !spriteObj.movement.rtHeld && !spriteObj.movement.upHeld && !spriteObj.movement.dnHeld && spriteObj.currentDirection) {      playAnimation('stopped');      spriteObj.currentDirection = false;    }  };  /****************************  * dgm.draw()  * Implements the dgm.draw() function  ****************************/  dgm.draw = function() {    //loop through images    for (var img_id in dgm.images) {      var imgObj = dgm.images[img_id];      dgm.canvas[imgObj.canvas].stage.addChild(imgObj.image);    }    //loop through sprites    for (var sprite_id in dgm.sprites) {      var spriteObj = dgm.sprites[sprite_id];      dgm.canvas[spriteObj.canvas].stage.addChild(spriteObj.sprite);    }  };  /****************************  * dgm.update()  * Implements the dgm.update() function  ****************************/  dgm.update = function() {    //loop through canvases    for (var canvas_id in dgm.canvas) {      var canvasObj = dgm.canvas[canvas_id];      canvasObj.stage.update();    }  };}(window));//register keypress functionsdocument.onkeydown = dgm.handleKeyDown;document.onkeyup = dgm.handleKeyUp;